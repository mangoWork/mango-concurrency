#### 数据库表里面的版本控制字段（version）---引出乐观锁与悲观锁

#### 解决了什么问题？

当多个事物对数据库中的同一条数据进行操作时，极易产生脏数据，而加锁机制则对改行为进行了制约。

#### 解决过程

##### 悲观锁

对数据会被外界修改产生脏数据持保守态度，即悲观的认为很有可能会产生数据冲突；

悲观锁的执行过程类似于精子对卵子的争夺，谁先抢到谁就给数据加上了排他锁，然后在进行相关事物操作，直到事物完成之后才会解锁；如果你加锁失败，说明她正在被修改。悲观锁在实际使用中是依靠数据库的锁机制来实现的。

##### 乐观锁

乐观的认为多个事物对一条数据进行修改产生数据冲突的可能性较小；

乐观锁的执行过程多利用数据库表里面的版本控制字段（version），每项事物均可对同一条数据进行操作，即获得这条数据的副本进行操作且版本version+1，然后在提交前夕对比数据库中的这条数据的版本是否和我获取时的一样，如果不一样这说明该数据已经被修改过了，自己做了无用功，需进行事物回滚；如果其版本和我刚拿到的副本的版本一致，则进行数据提交，完成操作。

或者利用数据库表中的时间戳字段，进行对数据进行操作之后，进行提交前，对比当前数据库中的时间戳和我当时取出来的时间戳是否一致，一致就提交操作将时间戳更换为最新的。

#### mysql实例

##### 悲观锁example：

在mysql中使用悲观锁需关闭mysql的自动提交属性，因为它默认使用autocommit模式：set autocommit = 0；

1.开启事物

2.select status from goods where id = 1 for update;(开启排他锁)

3.对锁定的数据进行操作

4.提交事物

注意事项：在使用select  ... for update 把数据锁住时，需要注意锁的级别，mysql innoDB默认使用行级锁，而行级锁是基于索引的，如果一条sql语句用不到索引则不会使用行级锁，而换用表级锁将整张表锁住。

##### 乐观锁example：

1.开启事物

2.得到数据（副本）

select （ status , status , version ）from foods where id = #{ id } 

3.操作数据

update goods set status = 2 , version = version + 1

where id = #{ id } and version = #{version};

在实际中常用乐观锁解决问题。












